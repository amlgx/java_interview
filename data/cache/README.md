# cache

## 怎么实现一个简单lrumap ?

## 缓存的种类有哪些？

浏览器缓存，静态文件缓存，进程内本地缓存，分布式缓存。

## 缓存的过期策略和存在的缺点？

LRU 最近最少被使用的数据被淘汰，重点是最近，淘汰最晚访问的缓存。

缺点是：可能会因为一次冷数据的批量查询而误淘汰大量热点数据。

LFU 最少被使用，淘汰最少命中的缓存。

缺点是：新数据很容易被淘汰。

FIFO 先入先出，淘汰最先写入的缓存。

限制是：用于特定领域，如作业调度和消息队列。

# 进程内本地缓存

## ehcache的特点，适用场景，以及存在的问题是什么？

Ehcache 的线程模型适合高并发应用，可以构成集群，简单快速。内存磁盘两层缓存，数据在虚拟机重启时可以写入和读取磁盘。

适用场景是：更新少，否则就不需要用缓存了。并发要求不严格，因为不能实时同步。对数据一致性要求不高，否则用集中式缓存如memcache，redis等，并且可以把ehcache用作二级缓存。

存在的问题有：缓存漂移，更新某节点后其他节点不动弹，就需要通过轮询或者消息队列来通知。数据库瓶颈，同时更新多个节点的缓存，数据库开销大，就需要使用数据库集群或者缓存分发。

## guava cache的特点和适用场景是什么？

guava cache是一个全内存的本地缓存，线程安全，功能完善，具有ConcurrentHashMap所不具备的缓存过期和数据的加载/刷新等功能。通过CacheLoader和Callable 回调创建，具体是使用CacheBuilder的静态方法建造Cache接口的对象，构造(使用)时传入CacheLoader(Callable)匿名对象。

适用场景是：消耗少量本地内存提升性能，更新锁定(refreshAfterWrite配置项，刷新时只允许一个请求回源，其他阻塞固定时间，没有新值就返回旧值)。

可以基于数据大小(maximumSize配置)，过期时间(expireAfterAccess/expireAfterWrite)和引用来删除，也可以主动删除(invalidate)。

# 分布式缓存

# 

